#!/usr/bin/env python3
# from typing import *

VAL = 100000000

# def solve(N: int, A: List[int]) -> int:
def solve(N, a):
    sm = 0
    a = sorted(a)

    # 全ての要素を合計してN-1倍し,母数を算出
    sm = sum(a) * (N-1)

    # 要素合計が 10^8 以上となる要素の検索
    # まず 隣接の和が 10^8 以上となる 行g, 列g+1 を探す
    g0 = None
    rlist = []
    flg = 0
    count = 0
    for i in range(N-1):
        s = a[i] + a[i+1]
        if s >= VAL: # 10^8以上であれば,その隣接和のあった行番号を格納しフラグon
            g0 = i
            flg = 1
            break
    # 隣接和がある場合(無い場合は処理しない)
    if flg == 1: 
        r = g0 + 1
        #rlist.append(r)
        for i in reversed(range(g0)): # 隣接和の行のひとつ上の行から, 列を検索するループを実施
            for j in range(r, N):
                s = a[i] + a[j]
                if s >= VAL:
                    r = j
                    rlist.append(r) # 10^8を超えた列番号を格納
                    break
        for r in rlist:
            count += N-r # 列番号から個数を算出 例3なら 3,4の2個 5-3=2

        for i in range(g0,N-1): # 隣接和の行とそれより下の行は全ての列をカウント
            count += N-1-i  # 例 2行目なら 2,3 2,4 の2個 なので 5-1-2=2

    sm -= VAL * count
    #print(rlist)
    return sm

# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    import sys
    tokens = iter(sys.stdin.read().split())
    N = int(next(tokens))
    A = [None for _ in range(N)]
    for i in range(N):
        A[i] = int(next(tokens))
    assert next(tokens, None) is None
    a = solve(N, A)
    print(a)

# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main2():
    with open("./abc353/abc353_c/test/sample-2.in") as f:
        a = f.read().split("\n")
    N = int(a[0])
    aa = list(map(int, a[1].split()))
    a = solve(N, aa)
    print(a)

if __name__ == '__main__':
    main()
